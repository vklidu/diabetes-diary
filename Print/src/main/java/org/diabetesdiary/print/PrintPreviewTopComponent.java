/*
 *   Copyright (C) 2006-2007 Jiri Majer. All Rights Reserved.
 *   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 *   This code is free software; you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License version 2 only, as
 *   published by the Free Software Foundation.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
package org.diabetesdiary.print;

import com.sun.pdfview.OutlineNode;
import com.sun.pdfview.PDFDestination;
import com.sun.pdfview.PDFFile;
import com.sun.pdfview.PDFObject;
import com.sun.pdfview.PDFPage;
import com.sun.pdfview.PagePanel;
import com.sun.pdfview.action.GoToAction;
import com.sun.pdfview.action.PDFAction;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.IOException;
import java.io.Serializable;
import java.util.logging.Logger;
import javax.swing.Action;
import javax.swing.InputMap;
import javax.swing.KeyStroke;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import org.diabetesdiary.print.pdf.PDFGenerator;
import org.diabetesdiary.print.print.PDFPrintSupport;
import org.openide.util.Exceptions;
import org.openide.util.ImageUtilities;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;

final class PrintPreviewTopComponent extends TopComponent implements TreeSelectionListener, KeyListener {

    private static PrintPreviewTopComponent instance;
    static final String ICON_PATH = "org/diabetesdiary/print/print.png";
    private static final String PREFERRED_ID = "PrintPreviewTopComponent";
    public final static Color DEFAULT_BACKGROUND = Color.DARK_GRAY;
    public final static Color THUMBS_BACKGROUND = new Color(0xF5F5F5);
    private PDFFile curFile;
    private int curpage = -1;
    private PagePreparer pagePrep;
    private Action unitScrollUp;
    private Action unitScrollDown;
    private Action scrollUp;
    private Action scrollDown;

    private PrintPreviewTopComponent() {
        initComponents();
        setName(NbBundle.getMessage(PrintPreviewTopComponent.class, "CTL_PrintPreviewTopComponent"));
        setToolTipText(NbBundle.getMessage(PrintPreviewTopComponent.class, "HINT_PrintPreviewTopComponent"));
        setIcon(ImageUtilities.loadImage(ICON_PATH, true));
        pagePanel = new PagePanel();
        try {
            curFile = new PDFGenerator(null).generateDocument();
            pagePanel.showPage(curFile.getPage(0));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        pageScroll.setViewportView(pagePanel);
        pagePanel.addKeyListener(this);
        //custom page panel key function
        InputMap im = pageScroll.getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        unitScrollUp = pageScroll.getActionMap().get(im.get(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0)));
        unitScrollDown = pageScroll.getActionMap().get(im.get(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0)));
        scrollUp = pageScroll.getActionMap().get(im.get(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_UP, 0)));
        scrollDown = pageScroll.getActionMap().get(im.get(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_DOWN, 0)));
        im.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), "none");
        im.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), "none");
        im.put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_UP, 0), "none");
        im.put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_DOWN, 0), "none");

        add(pageScroll, BorderLayout.CENTER);
        pageScroll.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent e) {
                super.componentResized(e);
                PrintPreviewTopComponent.this.gotoPage(curpage);
            }
        });
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pageScroll = new javax.swing.JScrollPane();
        jToolBar1 = new javax.swing.JToolBar();
        prevButton = new javax.swing.JButton();
        pageField = new javax.swing.JTextField();
        nextButton = new javax.swing.JButton();
        generateButton = new javax.swing.JButton();
        printButton = new javax.swing.JButton();
        savePDFButton = new javax.swing.JButton();

        jToolBar1.setRollover(true);

        org.openide.awt.Mnemonics.setLocalizedText(prevButton, "<");
        prevButton.setFocusable(false);
        prevButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        prevButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        prevButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prevButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(prevButton);

        pageField.setMaximumSize(new java.awt.Dimension(30, 50));
        pageField.setPreferredSize(new java.awt.Dimension(20, 20));
        jToolBar1.add(pageField);

        org.openide.awt.Mnemonics.setLocalizedText(nextButton, ">");
        nextButton.setFocusable(false);
        nextButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        nextButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        nextButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(nextButton);

        org.openide.awt.Mnemonics.setLocalizedText(generateButton, org.openide.util.NbBundle.getMessage(PrintPreviewTopComponent.class, "PrintPreviewTopComponent.generateButton.text")); // NOI18N
        generateButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(generateButton);

        org.openide.awt.Mnemonics.setLocalizedText(printButton, org.openide.util.NbBundle.getMessage(PrintPreviewTopComponent.class, "PrintPreviewTopComponent.printButton.text")); // NOI18N
        printButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                printButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(printButton);

        org.openide.awt.Mnemonics.setLocalizedText(savePDFButton, "savePDF");
        savePDFButton.setFocusable(false);
        savePDFButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        savePDFButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(savePDFButton);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(pageScroll, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                    .addComponent(jToolBar1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pageScroll, javax.swing.GroupLayout.DEFAULT_SIZE, 265, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void printButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_printButtonActionPerformed
        new PDFPrintSupport(curFile, "test").print();
    }//GEN-LAST:event_printButtonActionPerformed

    private void generateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateButtonActionPerformed
        try {
            openFile(new PDFGenerator(null).generateDocument());
        } catch (Exception ex) {
            Exceptions.printStackTrace(ex);
        }
    }//GEN-LAST:event_generateButtonActionPerformed

    private void prevButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prevButtonActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_prevButtonActionPerformed

    private void nextButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextButtonActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_nextButtonActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton generateButton;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JButton nextButton;
    private javax.swing.JTextField pageField;
    private javax.swing.JScrollPane pageScroll;
    private javax.swing.JButton prevButton;
    private javax.swing.JButton printButton;
    private javax.swing.JButton savePDFButton;
    // End of variables declaration//GEN-END:variables
    private PagePanel pagePanel;

    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link #findInstance}.
     */
    public static synchronized PrintPreviewTopComponent getDefault() {
        if (instance == null) {
            instance = new PrintPreviewTopComponent();
        }
        return instance;
    }

    /**
     * Obtain the PrintPreviewTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized PrintPreviewTopComponent findInstance() {
        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
        if (win == null) {
            Logger.getLogger(PrintPreviewTopComponent.class.getName()).warning(
                    "Cannot find " + PREFERRED_ID + " component. It will not be located properly in the window system.");
            return getDefault();
        }
        if (win instanceof PrintPreviewTopComponent) {
            return (PrintPreviewTopComponent) win;
        }
        Logger.getLogger(PrintPreviewTopComponent.class.getName()).warning(
                "There seem to be multiple components with the '" + PREFERRED_ID
                + "' ID. That is a potential source of errors and unexpected behavior.");
        return getDefault();
    }

    @Override
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }

    /** replaces this in object stream */
    @Override
    public Object writeReplace() {
        return new ResolvableHelper();
    }

    @Override
    protected String preferredID() {
        return PREFERRED_ID;
    }

    final static class ResolvableHelper implements Serializable {

        private static final long serialVersionUID = 1L;

        public Object readResolve() {
            return PrintPreviewTopComponent.getDefault();
        }
    }

    public void gotoPage(int pagenum) {
        if (pagenum < 0) {
            pagenum = 0;
        } else if (pagenum >= curFile.getNumPages()) {
            pagenum = curFile.getNumPages() - 1;
        }
        forceGotoPage(pagenum);
    }

    /**
     * Changes the displayed page.
     * @param pagenum the page to display
     */
    public void forceGotoPage(int pagenum) {
        if (pagenum <= 0) {
            pagenum = 0;
        } else if (pagenum >= curFile.getNumPages()) {
            pagenum = curFile.getNumPages() - 1;
        }
        curpage = pagenum;

        // update the page text field
        pageField.setText(String.valueOf(curpage + 1));

        // fetch the page and show it in the appropriate place
        PDFPage pg = curFile.getPage(pagenum + 1);
        pagePanel.showPage(pg);
        pagePanel.requestFocus();
        // stop any previous page prepper, and start a new one
        if (pagePrep != null) {
            pagePrep.quit();
        }
        pagePrep = new PagePreparer(pagenum);
        pagePrep.start();

        setEnabling();
    }

    /**
     * A class to pre-cache the next page for better UI response
     */
    class PagePreparer extends Thread {

        int waitforPage;
        int prepPage;

        /**
         * Creates a new PagePreparer to prepare the page after the current
         * one.
         * @param waitforPage the current page number, 0 based
         */
        public PagePreparer(int waitforPage) {
            setDaemon(true);

            this.waitforPage = waitforPage;
            this.prepPage = waitforPage + 1;
        }

        public void quit() {
            waitforPage = -1;
        }

        @Override
        public void run() {
            Dimension size = null;
            pagePanel.waitForCurrentPage();
            size = pagePanel.getCurSize();

            if (waitforPage == curpage) {
                PDFPage pdfPage = curFile.getPage(prepPage + 1, true);
                if (pdfPage != null && waitforPage == curpage) {
                    pdfPage.getImage(size.width, size.height, null, null, true, true);
                }
            }
        }
    }

    /**
     * Enable or disable all of the actions based on the current state.
     */
    public void setEnabling() {
        boolean fileavailable = curFile != null;
        boolean pageshown = pagePanel.getPage() != null;

        pageField.setEnabled(fileavailable);
        prevButton.setEnabled(pageshown);
        nextButton.setEnabled(pageshown);
    }

    /**
     * Open a specific pdf file.  Creates a DocumentInfo from the file,
     * and opens that.
     */
    public void openFile(PDFFile o) throws IOException {
        this.curFile = o;
        forceGotoPage(0);
    }

    /**
     * Goes to the next page
     */
    public void doNext() {
        gotoPage(curpage + 1);
    }

    /**
     * Goes to the previous page
     */
    public void doPrev() {
        gotoPage(curpage - 1);
    }

    /**
     * Goes to the first page
     */
    public void doFirst() {
        gotoPage(0);
    }

    /**
     * Goes to the last page
     */
    public void doLast() {
        gotoPage(curFile.getNumPages() - 1);
    }

    /**
     * Goes to the page that was typed in the page number text field
     */
    public void doPageTyped() {
        int pagenum = -1;
        try {
            pagenum = Integer.parseInt(pageField.getText()) - 1;
        } catch (NumberFormatException nfe) {
        }
        if (pagenum >= curFile.getNumPages()) {
            pagenum = curFile.getNumPages() - 1;
        }
        if (pagenum >= 0) {
            if (pagenum != curpage) {
                gotoPage(pagenum);
            }
        } else {
            pageField.setText(String.valueOf(curpage));
        }
    }
    /**
     * Handle a key press for navigation
     */
    int lastPos = 0;

    @Override
    public void keyPressed(KeyEvent evt) {
        int code = evt.getKeyCode();
        if (code == KeyEvent.VK_LEFT) {
            doPrev();
        } else if (code == KeyEvent.VK_RIGHT) {
            doNext();
        } else if (code == KeyEvent.VK_UP) {
            unitScrollUp.actionPerformed(new ActionEvent(pageScroll, code, TOOL_TIP_TEXT_KEY));
            if (pageScroll.getVerticalScrollBar().getValue() == lastPos) {
                doPrev();
            }
        } else if (code == KeyEvent.VK_DOWN) {
            unitScrollDown.actionPerformed(new ActionEvent(pageScroll, code, TOOL_TIP_TEXT_KEY));
            if (pageScroll.getVerticalScrollBar().getValue() == lastPos) {
                doNext();
            }
        } else if (code == KeyEvent.VK_HOME) {
            doFirst();
        } else if (code == KeyEvent.VK_END) {
            doLast();
        } else if (code == KeyEvent.VK_PAGE_UP) {
            scrollUp.actionPerformed(new ActionEvent(pageScroll, code, TOOL_TIP_TEXT_KEY));
            if (pageScroll.getVerticalScrollBar().getValue() == lastPos) {
                doPrev();
            }
        } else if (code == KeyEvent.VK_PAGE_DOWN) {
            scrollDown.actionPerformed(new ActionEvent(pageScroll, code, TOOL_TIP_TEXT_KEY));
            if (pageScroll.getVerticalScrollBar().getValue() == lastPos) {
                doNext();
            }
        } else if (code == KeyEvent.VK_SPACE) {
            doNext();
        }
        lastPos = pageScroll.getVerticalScrollBar().getValue();
    }

    /**
     * Combines numeric key presses to build a multi-digit page number.
     */
    class PageBuilder implements Runnable {

        int value = 0;
        long timeout;
        Thread anim;
        static final long TIMEOUT = 500;

        /** add the digit to the page number and start the timeout thread */
        public synchronized void keyTyped(int keyval) {
            value = value * 10 + keyval;
            timeout = System.currentTimeMillis() + TIMEOUT;
            if (anim == null) {
                anim = new Thread(this);
                anim.start();
            }
        }

        /**
         * waits for the timeout, and if time expires, go to the specified
         * page number
         */
        @Override
        public void run() {
            long now, then;
            synchronized (this) {
                now = System.currentTimeMillis();
                then = timeout;
            }
            while (now < then) {
                try {
                    Thread.sleep(timeout - now);
                } catch (InterruptedException ie) {
                }
                synchronized (this) {
                    now = System.currentTimeMillis();
                    then = timeout;
                }
            }
            synchronized (this) {
                gotoPage(value - 1);
                anim = null;
                value = 0;
            }
        }
    }
    PageBuilder pb = new PageBuilder();

    @Override
    public void keyReleased(KeyEvent evt) {
    }

    /**
     * gets key presses and tries to build a page if they're numeric
     */
    @Override
    public void keyTyped(KeyEvent evt) {
        char key = evt.getKeyChar();
        if (key >= '0' && key <= '9') {
            int val = key - '0';
            pb.keyTyped(val);
        }
    }

    @Override
    public void valueChanged(TreeSelectionEvent e) {
        if (e.isAddedPath()) {
            OutlineNode node = (OutlineNode) e.getPath().getLastPathComponent();
            if (node == null) {
                return;
            }
            try {
                PDFAction action = node.getAction();
                if (action == null) {
                    return;
                }

                if (action instanceof GoToAction) {
                    PDFDestination dest = ((GoToAction) action).getDestination();
                    if (dest == null) {
                        return;
                    }

                    PDFObject pageL = dest.getPage();
                    if (pageL == null) {
                        return;
                    }

                    int pageNum = curFile.getPageNumber(pageL);
                    if (pageNum >= 0) {
                        gotoPage(pageNum);
                    }
                }
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
    }
}
